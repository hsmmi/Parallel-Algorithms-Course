# Homework 1 – Matrix Multiplication Profiling

This repo contains a simple CPU‑bound dense matrix multiplication kernel and scripts to collect performance data.

## Goals

- Implement a baseline O(N³) multiplication: `C = A × B` with random inputs.
- Parameterise the problem size with `N` (e.g. 1024, 2048, 4096).
- Automate compilation and runs with the Makefile; average multiple runs (≥3) for each experiment.
- Use `gprof` and `perf` on Linux to profile and understand where time is spent.
- Explore how data type, matrix size, loop order, tiling and unrolling affect performance.

## Environment Preparation

Install a C++ toolchain with `g++`, `gprof` and `perf` (e.g. `apt install build-essential binutils linux-tools-common linux-tools-$(uname -r)`).

To compile and run the baseline code:

```sh
# clean previous binaries
make clean

# build and run once with default N=1024
make run

# average three runs and print the mean execution time
make run_avg RUNS=3

# profile with gprof (writes gprof_report_N1024.txt)
make gprof

# collect low‑level counters (cycles, instructions, cache misses)
make perf
```

## Changing parameters

The Makefile exposes several variables you can override on the command line:

 • **N** – the matrix dimension.  Default is 1024; override it to build a different sized kernel, e.g. make run N=2048.

 • **RUNS** – the number of repetitions for averaging or perf statistics.  For example, make run_avg RUNS=5 runs the program five times and prints the average.  The perf target uses perf stat -r $(RUNS) to compute the mean over multiple runs.

 • **PROG** – the program to compile, corresponding to the C++ source name without extension.  Place your variants in the src/ folder and run them by setting PROG, e.g. make run PROG=matmul_double.

## Directory structure

This project separates source code, binaries and results:

 • **src/** – all C++ source files live here (matmul_int.cpp, matmul_double.cpp, etc.).

 • **bin/** – compiled binaries are written here, with names that encode the program and N (e.g. matmul_int_N1024).

 • **results/run/** – averaged timing logs generated by the run_avg target.

 • **results/gprof/** – text reports from gprof (invoked via make gprof).

 • **results/perf/** – performance counter stats collected by perf (invoked via sudo make perf).

These directories are created automatically by the Makefile.  When you commit your results for the homework, include the contents of the results tree.

## Notes on perf

Collecting hardware events requires access to the CPU’s performance monitoring unit (PMU).  On some virtual machines the counters may be unavailable, in which case perf will report events as `<not supported>`.  In particular, running on a macOS host inside Parallels, VMware or other Mac hypervisors does not virtualise the PMU, so perf cannot measure cycles, instructions or cache misses.  To obtain valid hardware counters, run the code on a **native Linux machine** or a Linux VM on hardware that exposes the PMU, and invoke the perf target as root (e.g. sudo make perf).


## Optimization of Matrix Multiplication

